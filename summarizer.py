import requests
import time
from config import GROQ_API_KEY, DEFAULT_MODEL, FALLBACK_MODEL, MAX_RETRIES
from logger import logger

HEADERS = {
    "Authorization": f"Bearer {GROQ_API_KEY}",
    "Content-Type": "application/json"
}

def summarize_texts(posts: list, model: str = DEFAULT_MODEL, attempt=1) -> list:
    """
    –ì–µ–Ω–µ—Ä—É—î —Å–ø–∏—Å–æ–∫ —Å–∞–º–º–∞—Ä—ñ –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –ø–æ—Å—Ç–∞.
    –ü—ñ–¥—Ç—Ä–∏–º—É—î fallback-–º–æ–¥–µ–ª—å —Ç–∞ retry-–º–µ—Ö–∞–Ω—ñ–∑–º.
    """
    texts = [post["text"] for post in posts if post.get("text")]
    if not texts:
        logger.warning("üì≠ –£ –ø–æ—Å—Ç–∞—Ö –Ω–µ–º–∞—î —Ç–µ–∫—Å—Ç—É")
        return [{"title": "‚ùå –ù–µ–º–∞—î —Ç–µ–∫—Å—Ç—É", "summary": "–ü–æ—Å—Ç –ø–æ—Ä–æ–∂–Ω—ñ–π –∞–±–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∏–π"}]

    prompt = build_prompt(texts)
    payload = {
        "model": model,
        "messages": [
            {"role": "system", "content": "–°—Ç–∏—Å–ª–æ –ø—ñ–¥—Å—É–º—É–π –∫–æ–∂–µ–Ω —ñ–∑ –Ω–∞–≤–µ–¥–µ–Ω–∏—Ö –ø–æ—Å—Ç—ñ–≤. –î–æ–¥–∞–π –∑–∞–≥–æ–ª–æ–≤–æ–∫ —ñ –∫–æ—Ä–æ—Ç–∫–∏–π –æ–ø–∏—Å."},
            {"role": "user", "content": prompt}
        ]
    }

    try:
        start_time = time.time()
        response = requests.post("https://api.groq.com/openai/v1/chat/completions", headers=HEADERS, json=payload)
        duration = time.time() - start_time

        response.raise_for_status()
        result = response.json()["choices"][0]["message"]["content"]
        logger.info(f"‚úÖ Groq –≤—ñ–¥–ø–æ–≤—ñ–¥—å ({model}) –∑–∞ {duration:.2f}—Å")
        return parse_summaries(result, len(texts))

    except Exception as e:
        logger.warning(f"‚ö†Ô∏è [–°–ø—Ä–æ–±–∞ {attempt}] Groq –ø–æ–º–∏–ª–∫–∞ –¥–ª—è –º–æ–¥–µ–ª—ñ {model}: {e}")

        if attempt < MAX_RETRIES:
            time.sleep(2 * attempt)  # –µ–∫—Å–ø–æ–Ω–µ–Ω—Ü—ñ–∞–ª—å–Ω–∞ –∑–∞—Ç—Ä–∏–º–∫–∞
            return summarize_texts(posts, model=model, attempt=attempt + 1)

        elif model != FALLBACK_MODEL:
            logger.warning(f"üîÅ –ü–µ—Ä–µ—Ö–æ–¥–∏–º–æ –Ω–∞ fallback-–º–æ–¥–µ–ª—å: {FALLBACK_MODEL}")
            return summarize_texts(posts, model=FALLBACK_MODEL, attempt=1)

        else:
            logger.error("‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –∑–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ —Å–∞–º–º–∞—Ä—ñ –Ω–∞–≤—ñ—Ç—å –∑ fallback-–º–æ–¥–µ–ª–ª—é.")
            return [{"title": "‚ùå –ü–æ–º–∏–ª–∫–∞", "summary": "–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –¥–∞–π–¥–∂–µ—Å—Ç"}]

def build_prompt(texts: list) -> str:
    return "\n\n".join([f"{i+1}. {text.strip()}" for i, text in enumerate(texts)])

def parse_summaries(response_text: str, expected_count: int) -> list:
    """
    –°–ø–ª—ñ—Ç —Ç–µ–∫—Å—Ç—É –≤—ñ–¥ LLM –Ω–∞ –æ–∫—Ä–µ–º—ñ –±–ª–æ–∫–∏ –∑ –∑–∞–≥–æ–ª–æ–≤–∫–æ–º —ñ —Å–∞–º–º–∞—Ä—ñ.
    """
    summaries = response_text.strip().split("\n\n")
    parsed = []

    for s in summaries:
        lines = s.strip().split("\n", 1)
        title = lines[0].strip() if len(lines) > 0 else "–ë–µ–∑ –Ω–∞–∑–≤–∏"
        summary = lines[1].strip() if len(lines) > 1 else ""
        parsed.append({"title": title, "summary": summary})

    while len(parsed) < expected_count:
        parsed.append({"title": "‚ùå –ü—Ä–æ–ø—É—â–µ–Ω–æ", "summary": "LLM –Ω–µ –ø–æ–≤–µ—Ä–Ω—É–ª–∞ —Å–∞–º–º–∞—Ä—ñ."})

    return parsed[:expected_count]